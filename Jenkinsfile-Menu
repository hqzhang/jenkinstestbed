//////

def brch= scm.branches[0].toString()
brch=brch.substring(2,)
library("bitbucket-groovytest-lib@${brch}") _
import groovy.json.JsonSlurper

println "------branch11=${brch}"
println GroovySystem.version
def jobstr = Thread.currentThread().toString().substring(38,).split('/')[0]
def wksp="/var/root/.jenkins/workspace/${jobstr}"
def repo=scm.getUserRemoteConfigs().toString()
println "repo=$repo"
repo=repo.substring(9, repo.length()-8)
println "repo=$repo"
@groovy.transform.Field
def envList=['DEV','BAT']
@groovy.transform.Field
def serversList=[DEV: ['s11','ss22','ss33'],
                 BAT: ['s44','s55','s66'] ] 
@groovy.transform.Field
def defaultList=['ss33', 's55']
String buildDefault(List out,String key){
   def ret=[]
   out.each{ if(it.contains(key)){ ret.add(0, it) } else { ret.add(it) } }
   return ret
}
String setDefault(List out,String key){
   def ret=[]
   out.each{ if(it.contains(key)){ ret.add(0,'"'+it+'"') }  else { ret.add('"'+it+'"') } } 
   return ret
}         
String getServerScript(String refvar){
    def map=[:]
    envList.eachWithIndex{ it,index->
       map[it]=setDefault(serversList[it],defaultList[index])
    }
    return """def map=${map}
    |return map[${refvar}]
    |""".stripMargin()
}
def getPack(String mypath, String dft){
    println("enter getPack()")
    ret=[]
    def out="ssh root@192.168.0.16 ls ${mypath}/*.tar.gz".execute().text
    println "out=$out"
    out.readLines().each{ if( it.contains(dft) ){ ret.add(0,it) } else { ret.add(it) } }
    println "out=$out"
    return ret
}         
def getPackScript(String mypath, String dft){
   println("enter getPackScript()")
  return """ret=[]
  |def out="ssh root@192.168.0.16 ls ${mypath}/*.tar.gz".execute().text
  |out.readLines().each{ if( it.contains(\"${dft}\") ){ ret.add(0,it) } else { ret.add(it) } }
  |return ret
  |""".stripMargin()
}
def getFile(String wksp, String dft){
    println("enter getFile()")
    def ret=[]
    def out="ls ${wksp}/release  ".execute().text
    println "out=$out"
    out.readLines().each{ if( it.contains(dft) ){ ret.add(0,it) } else { ret.add(it) } }
    return ret
}         
def getFileScript(String wksp, String dft){
    println("enter getFileScript()....")
  return """def ret=[]
  |def out="ls ${wksp}/release  ".execute().text
  |out.readLines().each{ if( it.contains(\"${dft}\") ){ ret.add(0,it) } else { ret.add(it) } }
  |return ret
  |""".stripMargin()
}
def getContentScript(String wksp, String refvar ){
    println("enter getContentScript()....")
    return """
    |def out="cat ${wksp}/release/\${${refvar}}".execute().text
    |out=out.replaceAll('components:\\n','')
    |return \"\"\" <textarea name=\"value\"  value  class=\"setting-input  \" type=\"text\" rows="10" cols="25">\${out}</textarea> \"\"\"
    | """.stripMargin()
}

String getBranches( String myurl, String dft ){
   if ( !myurl?.trim() ) { myurl = url  }
   def gettags = ("git ls-remote --heads  $myurl  ").execute().text
   def ret = gettags.readLines().collect { it.split()[1].replaceAll('refs/heads/', '') }
   return buildDefault(ret, dft)
}
String getFileHub(String repo, String folder ){
   def ret=[]
   def cmd = """curl https://api.github.com/repos/${repo}/git/trees/master?recursive=2  """
   println "cmd=$cmd"
   def out = cmd.execute().text
   def jsonSlurper = new JsonSlurper()
   def obj = jsonSlurper.parseText(out)
   
   obj['tree'].each{
      if(it['path'].contains("${folder}/") ) { ret.add(it['path'])}
    }
   return ret
}
def getFileBit(String repo, String folder){
    println "ener getFileBit()"
    def repoPR="https://api.bitbucket.org/2.0/repositories/$repo/src/master/releases"
    def ret=[]
    //def cmd="curl -u fredzhang123:ATBBFSVPkWdLh9LjtZpc2wWXeNqADB6891B3 --request GET ${repoPR}  "
    def cmd="curl --request GET ${repoPR}  "
    def out=cmd.execute().text
    println "out=$out"
    def json=new JsonSlurper()
    def obj=json.parseText(out)
  
    obj['values'].each { ret.add(it['path'])}
    return ret
    }

def getFileBitScript(String repo, String folder){
    return """import groovy.json.JsonSlurper
    |def ret=[]
    |def repoPR="https://api.bitbucket.org/2.0/repositories/${repo}/src/master/releases"
    |def cmd="curl --request GET \${repoPR}  "
    |def out=cmd.execute().text
    |def json=new JsonSlurper()
    |def obj=json.parseText(out)
    |obj['values'].each { ret.add(it['path'])}
    |return ret
    | """.stripMargin()
}
//println getPack('/root/workspace/myscripts','myfile')
println getFileBit("wave-cloud/groovytest","releases")

properties([
    //pipelineTriggers([bitbucketPush()]),
    parameters([
            choice( name: 'Environment', description: '', choices: buildDefault(envList,'BAT') ),
            choice( name: 'getBranches', description: '', choices: getBranches(repo, 'master') ),
            choice( name: 'getFileHub', description: '', choices: getFileHub("hqzhang/groovytest","releases") ),
            choice( name: 'getFileBit', description: '', choices: getFileBit("wave-cloud/groovytest","releases") ),
            [$class: 'CascadeChoiceParameter', choiceType: 'PT_SINGLE_SELECT', filterLength: 1, filterable: false,
               name: 'getFileBitScript', randomName: 'choice-parameter-16677189047472', referencedParameters: 'Environment', 
               script: [$class: 'GroovyScript', fallbackScript: [classpath: [], oldScript: '', sandbox: true, script: ''], 
               script: [classpath: [], oldScript: '', sandbox: true, 
               script: getFileBitScript("hqzhang/groovytest","releases") ]]],
            [$class: 'CascadeChoiceParameter', choiceType: 'PT_SINGLE_SELECT', filterLength: 1, filterable: false,
               name: 'Server', randomName: 'choice-parameter-16677189047472', referencedParameters: 'Environment', 
               script: [$class: 'GroovyScript', fallbackScript: [classpath: [], oldScript: '', sandbox: true, script: ''], 
               script: [classpath: [], oldScript: '', sandbox: true, 
               script: getServerScript('Environment') ]]],

            [$class: 'CascadeChoiceParameter', choiceType: 'PT_SINGLE_SELECT', filterLength: 1, filterable: false,
               name: 'Package', randomName: 'choice-parameter-16677189047489', referencedParameters: 'filebackup', 
               script: [$class: 'GroovyScript', fallbackScript: [classpath: [], oldScript: '', sandbox: false, script: ''], 
               script: [classpath: [], oldScript: '', sandbox: false, 
               script: getPackScript('/root/workspace/myscripts','myfile') ]]],

            [ $class: 'CascadeChoiceParameter', choiceType: 'PT_SINGLE_SELECT', filterLength: 1, filterable: false,
               name: 'SolutionConfig', randomName: 'choice-parameter-16677189047798', referencedParameters: 'filebackup', 
               script: [$class: 'GroovyScript', fallbackScript: [classpath: [], oldScript: '', sandbox: false, script: ''], 
               script: [classpath: [], oldScript: '', sandbox: false, 
               script: getFileScript(wksp,'solution') ]]],

            [$class: 'DynamicReferenceParameter', choiceType: 'ET_FORMATTED_HTML', name: 'Component',
             omitValueField: false, randomName: 'choice-parameter-138673186839723', referencedParameters: 'SolutionConfig', 
            script: [$class: 'GroovyScript', fallbackScript: [classpath: [], oldScript: '', sandbox: false, script: ''],
                     script: [classpath: [], oldScript: '', sandbox: false, 
                              script: getContentScript(wksp,'SolutionConfig')]] ], 

            [$class: 'DynamicReferenceParameter', choiceType: 'ET_FORMATTED_HTML', name: 'Components', 
             omitValueField: false, randomName: 'choice-parameter-138673186839723', referencedParameters: 'SolutionConfig', 
            script: [$class: 'GroovyScript', fallbackScript: [classpath: [], oldScript: '', sandbox: false, script: ''],
                     script: [classpath: [], oldScript: '', sandbox: false, 
                              script: menu.getContentTable('SolutionConfig' )]] ],
           
            string(name: 'filebackup', defaultValue: 'backup.yaml', description: 'input file to backup'),

             
])
])////
println "begin pipeline"
def map
def list
def remote = [:]
remote.name = "root"
remote.host = "192.168.0.16"
remote.allowAnyHosts = true
//println menu.getCompList('mypack')
//println menu.gitCompVerify()
pipeline {
    agent any
    stages {
        stage('Create List') {
            steps {
                script {
                    echo "STAGE: create List..."
                    echo "params======$params"
                    echo "components=${env.compNames}"
                    echo "init=$env.initMenu"
                    println "get use function"
                    def comps=["b","a"]
                    def versions=["1","2"]
                    comps.eachWithIndex{ var, id->
                          echo "com=$comps[id]"
                          echo "ver=$versions[id]"

                    }
                     
                        sh """
                        echo comp
                        """
                    //println menu.getCompList('mypack')
                   
                    
                   /* withCredentials([sshUserPrivateKey(credentialsId: 'b2c30d83-4635-4fe4-870c-91b9fafef3c9',
                             keyFileVariable: 'identity', passphraseVariable: '', usernameVariable: 'userName')]) {
                        remote.user = userName
                        remote.identityFile = identity
                  
                        writeFile file: 'abc.sh', text: 'ls'
                        sshCommand remote: remote, command: 'for i in {1..5}; do echo -n \"Loop \$i \"; date ; sleep 1; done'
                        sshPut remote: remote, from: 'abc.sh', into: '.'
                        sshGet remote: remote, from: 'abc.sh', into: 'bac.sh', override: true
                        sshScript remote: remote, script: 'abc.sh'
                       */
                    /*sh """
                        ls -al ./scripts/run.sh
                        chmod a+x ./scripts/run.sh
                        ./scripts/run.sh
                    """

                    if ( env.initMenu.toBoolean() == true ){
                        echo "Menu is initialized Successfully!"
                        return
                    }
                    echo "parsing yaml"
                    println ("Components={env.Components}") 
                    println ("Component={env.Component}")
                    if ( env.Components == '' ){
                        echo "Components is not SET"
                        sh 'exit 1'
                    }
                    def file = new File("${wksp}/releases/${filebackup}")
                    echo  "file Exist: ${file.exists()}"
                    if (file.exists()) {
                        echo "delete file"
                        file.delete()
                    }
                    echo  "file Exist: ${file.exists()}"
                   
                    println "for comma string"
                    def read = menu.stringParse(env.Components)
                    println read
                    
                    writeYaml file: "${wksp}/releases/${filebackup}", data: read
                    //writeFile file: "releases/${filebackup}", text: multiLineStr
                    //def st=new File("/path-to-file").exists()

                    //menu.writeYamlFile("releases/${filebackup}",read)
                    sh "cat releases/${filebackup}"

                     ///println for yaml string
                    def multiLineStr = params.Component.replaceAll(/\\n/,"\n").replaceAll(',','')
                    println "multiLineStr=$multiLineStr"
                     */
                    
                    
                    /*def targtServer=params.servers
                    echo "params=$params"
                    if ( targtServer.equals('ERROR') ) 
                    {
                        targtServer='s23'
                    }
                    
                    echo "targtServer=$targtServer"
                    workspace=WORKSPACE
                    println "WS=${env.WORKSPACE}"
                    println "WS=${WORKSPACE}"
                    println "pwd="+pwd()
                    println "workspace=$workspace"
                    // you may create your list here, lets say reading from a file after checkout
                    //list = ["Test-1", "Test-2", "Test-3", "Test-4", "Test-5"]
                    list = readXMLList("${workspace}/manifest_Lynx.xml")
                    echo "***************"
                    def jsonText = parseXML("${workspace}/manifest_Lynx.xml")
                    map = readJSON text: jsonText
                    echo "#################"
                     def remote = [:]
                    remote.name = 'test'
                    remote.host = '192.168.2.27'
                    remote.user = 'root'
                    remote.password = 'password'
                    remote.allowAnyHosts = true
    
                    sshCommand remote: remote, command: "ls -lrt"*/
    
                }
            }
        }
   }
}


