//////

def brch= scm.branches[0].toString()
brch=brch.substring(2,)
library("bitbucket-groovytest-lib@${brch}") _
println "------branch=${brch}"
println GroovySystem.version
menu.checkBuildRunning()
def repo=menu.getRepo()
println "------repo=$repo"

def jobstr = menu.getJob()
println "------jobstr=$jobstr"


def wksp=menu.getWksp()
println "------wksp=${wksp}"


println "call getFileList"
println menu.getFileList('solution',wksp) 
println "call getContent100"
println menu.getContent100('Config' ,wksp,repo,brch )
println "begin properties"
println menu.getPackList('')
println menu.getContent('Config' ,wksp,repo,brch )
//////////
properties([
    pipelineTriggers([bitbucketPush()]),
    parameters([
        separator(name: "building"),
		    
            choice( name: 'mypack', description: '', choices: menu.getPackList('') ),
            [$class: 'CascadeChoiceParameter', choiceType: 'PT_CHECKBOX', filterLength: 1, filterable: false,
               name: 'compoents', randomName: 'choice-parameter-16677189047472', referencedParameters: 'mypack', 
               script: [$class: 'GroovyScript', fallbackScript: [classpath: [], oldScript: '', sandbox: false, script: ''], 
               script: [classpath: [], oldScript: '', sandbox: false, 
               script: '''if ( mypack == "configuration") { return ["component1:selected", "component2:selected", "component3"]} 
                        else if ( mypack == "solution") { return ["comp1", "comp2:selected", "comp3"]} 
                        else if ( mypack == "environment") { return ["cmp1", "cmp2", "cmp3:selected"] }''' ]]],
            choice( name: 'Soltail', description: '', choices: [ brch,jobstr,repo] ),

            booleanParam(name: 'initMenu', defaultValue: false, description: 'set for init menu'),
        
            choice( name: 'Config', description: '', choices: menu.getFileList('solution',wksp) ),
            [$class: 'DynamicReferenceParameter', choiceType: 'ET_FORMATTED_HTML', name: 'Components', omitValueField: false, 
            randomName: 'choice-parameter-138673186839723', referencedParameters: 'Config', 
            script: [$class: 'GroovyScript', fallbackScript: [classpath: [], oldScript: '', sandbox: false, script: ''],
                     script: [classpath: [], oldScript: '', sandbox: false, 
                              script: menu.getContent100('Config' ,wksp,repo,brch )]] ],
            [$class: 'DynamicReferenceParameter', choiceType: 'ET_FORMATTED_HTML', name: 'Component', omitValueField: false, 
            randomName: 'choice-parameter-138673186839723', referencedParameters: 'Config', 
            script: [$class: 'GroovyScript', fallbackScript: [classpath: [], oldScript: '', sandbox: false, script: ''],
                     script: [classpath: [], oldScript: '', sandbox: false, 
                              script: menu.getContent('Config' ,wksp,repo,brch )]] ],
            string(name: 'filebackup', defaultValue: 'backup.yaml', description: 'input file to backup'),
             
])
])//
println "begin pipeline"
def map
def list
def remote = [:]
remote.name = "root"
remote.host = "192.168.0.16"
remote.allowAnyHosts = true
println menu.getCompList('mypack')
println menu.gitCompVerify()
pipeline {
    agent any
    stages {
        stage('Create List') {
            steps {
                script {
                    echo "STAGE: create List..."
                    echo "params======$params"
                    echo "init=$env.initMenu"
                    println "get use function"
                    println menu.getCompList('package')
                   
                    
                    withCredentials([sshUserPrivateKey(credentialsId: 'b2c30d83-4635-4fe4-870c-91b9fafef3c9',
                             keyFileVariable: 'identity', passphraseVariable: '', usernameVariable: 'userName')]) {
                        remote.user = userName
                        remote.identityFile = identity
                  
                        writeFile file: 'abc.sh', text: 'ls'
                        sshCommand remote: remote, command: 'for i in {1..5}; do echo -n \"Loop \$i \"; date ; sleep 1; done'
                        sshPut remote: remote, from: 'abc.sh', into: '.'
                        sshGet remote: remote, from: 'abc.sh', into: 'bac.sh', override: true
                        sshScript remote: remote, script: 'abc.sh'
                        sshRemove remote: remote, path: 'abc.sh'
                    }
                    /*sh """
                        ls -al ./scripts/run.sh
                        chmod a+x ./scripts/run.sh
                        ./scripts/run.sh
                    """

                    if ( env.initMenu.toBoolean() == true ){
                        echo "Menu is initialized Successfully!"
                        return
                    }
                    echo "parsing yaml"
                    println ("Components={env.Components}") 
                    println ("Component={env.Component}")
                    if ( env.Components == '' ){
                        echo "Components is not SET"
                        sh 'exit 1'
                    }
                    def file = new File("${wksp}/releases/${filebackup}")
                    echo  "file Exist: ${file.exists()}"
                    if (file.exists()) {
                        echo "delete file"
                        file.delete()
                    }
                    echo  "file Exist: ${file.exists()}"
                   
                    println "for comma string"
                    def read = menu.stringParse(env.Components)
                    println read
                    
                    writeYaml file: "${wksp}/releases/${filebackup}", data: read
                    //writeFile file: "releases/${filebackup}", text: multiLineStr
                    //def st=new File("/path-to-file").exists()

                    //menu.writeYamlFile("releases/${filebackup}",read)
                    sh "cat releases/${filebackup}"

                     ///println for yaml string
                    def multiLineStr = params.Component.replaceAll(/\\n/,"\n").replaceAll(',','')
                    println "multiLineStr=$multiLineStr"
                     */
                    
                    
                    /*def targtServer=params.servers
                    echo "params=$params"
                    if ( targtServer.equals('ERROR') ) 
                    {
                        targtServer='s23'
                    }
                    
                    echo "targtServer=$targtServer"
                    workspace=WORKSPACE
                    println "WS=${env.WORKSPACE}"
                    println "WS=${WORKSPACE}"
                    println "pwd="+pwd()
                    println "workspace=$workspace"
                    // you may create your list here, lets say reading from a file after checkout
                    //list = ["Test-1", "Test-2", "Test-3", "Test-4", "Test-5"]
                    list = readXMLList("${workspace}/manifest_Lynx.xml")
                    echo "***************"
                    def jsonText = parseXML("${workspace}/manifest_Lynx.xml")
                    map = readJSON text: jsonText
                    echo "#################"
                     def remote = [:]
                    remote.name = 'test'
                    remote.host = '192.168.2.27'
                    remote.user = 'root'
                    remote.password = 'password'
                    remote.allowAnyHosts = true
    
                    sshCommand remote: remote, command: "ls -lrt"*/
    
                }
            }
        }
   }
}


